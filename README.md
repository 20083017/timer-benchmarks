# timerqueue-benchmark

分别使用最小堆、红黑树、时间轮实现定时器，再对插入、删除、循环做性能测试。


# 如何构建本项目

* 下载[premake](https://premake.github.io/download.html#v5)
* 使用premake生成Visual Studio解决方案或者makefile，如`premake5 vs2017`


# 性能测试

## 算法复杂度

复杂度比较：

```
algo   | Add()    | Cancel() | Tick()   | impl
--------------------------------------------------------
最小堆 | O(log N) | O(N) | O(1)     | src/PQTimer.h
红黑树 | O(log N) | O(N) | O(log N) | src/TreeTimer.h
时间轮 | O(1)     | O(1)     | O(1)     | src/WheelTimer.h
```

最小堆和红黑树的Cancel算法均使用for遍历找到id做删除，所以都是O(N)复杂度。



```
E5 2.3GHz CentOS 7
============================================================================
test/BenchTimer.cpp                              relative  time/iter  iters/s
============================================================================
PQTimerAdd                                                 766.66ms     1.30
TreeTimerAdd                                      58.56%      1.31s  763.80m
WheelTimerAdd                                    208.50%   367.70ms     2.72
----------------------------------------------------------------------------
PQTimerDel                                                 382.66ms     2.61
TreeTimerDel                                     129.61%   295.24ms     3.39
WheelTimerDel                                    242.69%   157.67ms     6.34
----------------------------------------------------------------------------
PQTimerTick                                                566.14ms     1.77
TreeTimerTick                                     78.72%   719.17ms     1.39
WheelTimerTick                                    88.99%   636.17ms     1.57
============================================================================
```

```
i3 1.9GHz Windows 7
============================================================================
test\BenchTimer.cpp                              relative  time/iter  iters/s
============================================================================
PQTimerAdd                                                 161.07ms     6.21
TreeTimerAdd                                      58.29%   276.30ms     3.62
WheelTimerAdd                                     35.44%   454.42ms     2.20
----------------------------------------------------------------------------
PQTimerDel                                                 271.24ms     3.69
TreeTimerDel                                     517.92%    52.37ms    19.09
WheelTimerDel                                    140.29%   193.34ms     5.17
----------------------------------------------------------------------------
PQTimerTick                                                 53.77ms    18.60
TreeTimerTick                                     60.14%    89.41ms    11.19
WheelTimerTick                                    45.62%   117.85ms     8.49
============================================================================
```


# 结论
 
* 最小堆很出色，红黑树性能没想象中那么低，相反，时间轮实现的性能低于预期的O(1)（抑或是我实现不够好？）
* 最小堆的编码实现最简单，大多数编程语言都可以迅速实现，实现难度：最小堆 < 时间轮 < 红黑树

## TO-DO

* 时间轮实现还可以做内存优化
* 集成[其它benchmark框架](https://github.com/google/benchmark)来跑性能数据
